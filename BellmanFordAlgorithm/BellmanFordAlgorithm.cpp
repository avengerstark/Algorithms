// BellmanFordAlgorithm.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
using namespace std;
// Алгоритм Форда-Беллмана

const int INF = INT_MAX / 2; // типа бесконечность
struct edge // структура хранит ребро и вес
{
	int from, to, weight;
};
int n, m, s, x; // количество вершин, количество ребер, начальная вершина и флаг для определения отрицательного цикла
edge e [2000]; // массив для хранения ребер и вес ребра
int d [1000]; // расстояние до начальной вершины 
int p [1000]; // массив предков, необходимых для восстановления кратчайшего пути из стартовой вершины



// Алгоритм
void BellmanFordAlgorithm(int v) // v - вершина от куда будет производится поиск кратчайших путей
{
	d[v] = 0; // расстояние из начальной вершины в саму себя равна 0

	for (int i = 0; i<n; i++) // делаем лишнюю итерацию для определения отрицательного цикла
	{
		x = -1;
		//bool any = false; // Флаг для проверки, прошла ли релаксация, если нет, прерываем цикл, чтобы не производить лишние итерации
		for (int j = 0; j < m; j++)
		{
			int from = e[j].from;
			int to = e[j].to;
			int weight = e[j].weight;

			// Ясно, что если вершина from на
			// текущем шаге работы алгоритма
			// находится бесконечно далеко от
			// 0-ой, то она не изменит ответ
			if (d[from] == INF)
				continue;
			// Обновляем дистанцию, если текущий вес больше предлагаемой  - релаксация
			if (d[to] > d[from] + weight){
				d[to] = d[from] + weight;
				p[to] = from; // запоминаем предшествующую вершину
				x = to;
				/*any = true;*/
			}			
		}
		//if (!any) // прерываем цикл если релаксация ни по одному ребру не прошла
		//	break;
	}


	for (int i = 0; i < n; i++)
		cout << d[i] << "   ";

	if (x == -1)
	{
		cout << "\nГраф не содержит отрицательный цикл\n";
	}
	else
	{
		cout << "\nГраф содержит отрицательный цикл\n";


		// вершина x будет либо лежать на цикле отрицательного веса, либо она достижима из него. Чтобы получить вершину,
		// которая гарантированно лежит на цикле, достаточно, например, n раз пройти по предкам, начиная от вершины x
		int y = x;
		for (int i = 0; i < n; i++)
		{
			y = p[y];
		}

		// Получив номер y вершины, лежащей на цикле, надо пройтись от этой вершины по предкам, 
		//пока мы не вернёмся в эту же вершину y (а это обязательно произойдёт,
		// потому что релаксации в цикле отрицательного веса происходят по кругу).

		vector<int> path;
		for (int cur = y;; cur = p[cur]) {
			path.push_back(cur);
			if (cur == y && path.size() > 1)  break;
		}
		reverse(path.begin(), path.end());

		for (size_t i = 0; i < path.size(); ++i)
			cout << path[i]+1 << ' ';

	}



}


// Функция восстановления кратчайших путей
void Travel(int v)
{
	if (p[v] == -1)
	{
		cout << v + 1 << " ";
	}
	else
	{
		Travel(p[v]);
		cout << v + 1<< " ";
	}
}


// Считываем данные
void ReadData()
{

	cout << "Введите количество вершин : "; cin >> n;
	cout << "Введите количество ребер : "; cin >> m;
	cout << "Введите начальную вершину : "; cin >> s;
	--s;
	// инициализируем массив расстоянии бесконечностями
	for (int i = 0; i < n; i++)
	{
		d[i] = INF;
	}
	
	// инициализируем массив предков 
	for (int i = 0; i < n ; i++)
	{
		p[i] = -1;
	}

	cout << "\nВводите ребра и их вес : \n";
	for (int i = 0; i < m; i++)
	{
		cout << "From : "; cin >> e[i].from;
		cout << "To : "; cin >> e[i].to;
		--e[i].from;
		--e[i].to;
		cout << "Weight : "; cin >> e[i].weight;
		if(i<m-1)
			cout << "----------------------------\n";
		
	}
	
}


int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL, "Rus");
	ReadData();
	cout << endl;
	BellmanFordAlgorithm(s);
	
	int v;
	cout << "\nВведите вершину, до которой нужно проложить кратчайший путь : "; cin >> v;
	--v;
	Travel(v);
	cout << endl;
	return 0;

}

